var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/index.ts
import "@mapbox/search-js-web";
import { config } from "@mapbox/search-js-web";

// src/components/AddressAutofill.tsx
import React, { useRef, useEffect, useImperativeHandle } from "react";
var AddressAutofill = React.forwardRef((props, refProp) => {
  const {
    accessToken,
    options,
    theme,
    popoverOptions,
    confirmOnBrowserAutofill,
    children,
    onSuggest,
    onSuggestError,
    onRetrieve
  } = props;
  const ref = useRef();
  useImperativeHandle(refProp, () => ({
    focus: () => {
      if (ref.current)
        return ref.current.focus();
      throw new Error("AddressAutofill is not mounted");
    }
  }));
  useEffect(() => {
    if (ref.current)
      ref.current.options = options;
  }, [ref.current, options]);
  useEffect(() => {
    if (ref.current)
      ref.current.theme = theme;
  }, [ref.current, theme]);
  useEffect(() => {
    if (ref.current)
      ref.current.popoverOptions = popoverOptions;
  }, [ref.current, popoverOptions]);
  useEffect(() => {
    if (ref.current)
      ref.current.confirmOnBrowserAutofill = confirmOnBrowserAutofill;
  }, [ref.current, confirmOnBrowserAutofill]);
  useEffect(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onSuggest)
      return;
    const fn = (e) => onSuggest(e.detail);
    node.addEventListener("suggest", fn);
    return () => {
      node.removeEventListener("suggest", fn);
    };
  }, [ref.current, onSuggest]);
  useEffect(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onSuggestError)
      return;
    const fn = (e) => onSuggestError(e.detail);
    node.addEventListener("suggesterror", fn);
    return () => {
      node.removeEventListener("suggesterror", fn);
    };
  }, [ref.current, onSuggestError]);
  useEffect(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onRetrieve)
      return;
    const fn = (e) => onRetrieve(e.detail);
    node.addEventListener("retrieve", fn);
    return () => {
      node.removeEventListener("retrieve", fn);
    };
  }, [ref.current, onRetrieve]);
  useEffect(() => {
    if (ref.current)
      ref.current.accessToken = accessToken;
  }, [ref.current, accessToken]);
  return /* @__PURE__ */ React.createElement("mapbox-address-autofill", {
    ref
  }, children);
});

// src/components/SearchBox.tsx
import React2, { useRef as useRef2, useEffect as useEffect2, useImperativeHandle as useImperativeHandle2 } from "react";
var SearchBox = React2.forwardRef((props, refProp) => {
  const {
    accessToken,
    options,
    theme,
    popoverOptions,
    map,
    value,
    onChange,
    onSuggest,
    onSuggestError,
    onRetrieve
  } = props;
  const ref = useRef2();
  useImperativeHandle2(refProp, () => ({
    focus: () => {
      if (ref.current)
        return ref.current.focus();
      throw new Error("SearchBox is not mounted");
    }
  }));
  useEffect2(() => {
    if (ref.current)
      ref.current.options = options;
  }, [ref.current, options]);
  useEffect2(() => {
    if (ref.current)
      ref.current.theme = theme;
  }, [ref.current, theme]);
  useEffect2(() => {
    if (ref.current)
      ref.current.popoverOptions = popoverOptions;
  }, [ref.current, popoverOptions]);
  useEffect2(() => {
    if (ref.current)
      ref.current.value = value;
  }, [ref.current, value]);
  useEffect2(() => {
    const node = ref.current;
    if (!node)
      return;
    node.bindMap(map);
    return () => {
      node.unbindMap();
    };
  }, [ref.current, map]);
  useEffect2(() => {
    const node = ref.current;
    if (!node)
      return;
    const fn = (e) => onSuggest(e.detail);
    node.addEventListener("suggest", fn);
    return () => {
      node.removeEventListener("suggest", fn);
    };
  }, [ref.current, onSuggest]);
  useEffect2(() => {
    const node = ref.current;
    if (!node)
      return;
    const fn = (e) => onSuggestError(e.detail);
    node.addEventListener("suggesterror", fn);
    return () => {
      node.removeEventListener("suggesterror", fn);
    };
  }, [ref.current, onSuggestError]);
  useEffect2(() => {
    const node = ref.current;
    if (!node)
      return;
    const fn = (e) => onRetrieve(e.detail);
    node.addEventListener("retrieve", fn);
    return () => {
      node.removeEventListener("retrieve", fn);
    };
  }, [ref.current, onRetrieve]);
  useEffect2(() => {
    const node = ref.current;
    if (!node)
      return;
    const fn = (e) => onChange(e.detail);
    node.addEventListener("input", fn);
    return () => {
      node.removeEventListener("input", fn);
    };
  }, [ref.current, onChange]);
  useEffect2(() => {
    if (ref.current)
      ref.current.accessToken = accessToken;
  }, [ref.current, accessToken]);
  return /* @__PURE__ */ React2.createElement("mapbox-search-box", {
    ref
  });
});

// src/components/AddressMinimap.tsx
import React3, { useRef as useRef3, useEffect as useEffect3 } from "react";
function AddressMinimap(props) {
  const {
    canAdjustMarker = false,
    keepMarkerCentered = false,
    markerAnchor = "bottom",
    onSaveMarkerLocation,
    show = false,
    accessToken,
    feature = null,
    satelliteToggle = false,
    theme,
    mapStyleMode = "default",
    defaultMapStyle = ["mapbox", "streets-v11"],
    footer
  } = props;
  const ref = useRef3();
  useEffect3(() => {
    if (!ref.current)
      return;
    if (show) {
      ref.current.show();
    } else {
      ref.current.hide();
    }
  }, [ref.current, show]);
  useEffect3(() => {
    if (ref.current)
      ref.current.theme = theme;
  }, [ref.current, theme]);
  useEffect3(() => {
    if (ref.current)
      ref.current.feature = show ? feature : null;
  }, [ref.current, feature, show]);
  useEffect3(() => {
    if (ref.current)
      ref.current.mapStyleMode = mapStyleMode;
  }, [ref.current, mapStyleMode]);
  useEffect3(() => {
    if (ref.current)
      ref.current.defaultMapStyle = defaultMapStyle;
  }, [ref.current, defaultMapStyle]);
  useEffect3(() => {
    if (footer === void 0)
      return;
    if (ref.current)
      ref.current.footer = footer;
  }, [ref.current, footer]);
  useEffect3(() => {
    if (ref.current)
      ref.current.accessToken = accessToken;
  }, [ref.current, accessToken]);
  useEffect3(() => {
    if (ref.current)
      ref.current.onSaveMarkerLocation = onSaveMarkerLocation;
  }, [ref.current, onSaveMarkerLocation]);
  return /* @__PURE__ */ React3.createElement("mapbox-address-minimap", {
    ref,
    "can-adjust-marker": canAdjustMarker,
    "keep-marker-centered": keepMarkerCentered,
    "marker-anchor": markerAnchor,
    "satellite-toggle": satelliteToggle
  });
}

// src/hooks/useEvented.tsx
import { useEffect as useEffect4, useRef as useRef4 } from "react";
function useEvented(evented, eventName, cb) {
  const cbRef = useRef4(cb);
  useEffect4(() => {
    cbRef.current = cb;
  });
  useEffect4(() => {
    if (!evented)
      return;
    const fn = (object) => cbRef.current(object);
    evented.addEventListener(eventName, fn);
    return () => {
      evented.removeEventListener(eventName, fn);
    };
  }, [evented, eventName, cbRef]);
}

// src/hooks/useMapboxAutofill.tsx
import { useEffect as useEffect5, useMemo } from "react";
import { MapboxAutofill } from "@mapbox/search-js-core";
var DEFAULTS = MapboxAutofill.defaults;
function useMapboxAutofill(options) {
  const autofill = useMemo(() => {
    return new MapboxAutofill();
  }, []);
  useEffect5(() => {
    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, ["accessToken"]);
    autofill.accessToken = accessToken;
    autofill.defaults = __spreadValues(__spreadValues({}, DEFAULTS), restOptions);
  }, [options]);
  return autofill;
}

// src/hooks/useMapboxSearch.tsx
import { useEffect as useEffect6, useMemo as useMemo2 } from "react";
import { MapboxSearch } from "@mapbox/search-js-core";
var DEFAULTS2 = MapboxSearch.defaults;
function useMapboxSearch(options) {
  const search = useMemo2(() => {
    return new MapboxSearch();
  }, []);
  useEffect6(() => {
    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, ["accessToken"]);
    search.accessToken = accessToken;
    search.defaults = __spreadValues(__spreadValues({}, DEFAULTS2), restOptions);
  }, [options]);
  return search;
}

// src/hooks/useSearchSession.tsx
import {
  MapboxSearch as MapboxSearch2,
  SearchSession
} from "@mapbox/search-js-core";
import { useMemo as useMemo3 } from "react";
function useSearchSession(search) {
  const searchSession = useMemo3(() => {
    return new SearchSession(search);
  }, [search]);
  if (search instanceof MapboxSearch2) {
    return searchSession;
  } else {
    return searchSession;
  }
}

// src/hooks/useConfirmAddress.tsx
import { useMemo as useMemo4, useRef as useRef5 } from "react";
import {
  confirmAddress
} from "@mapbox/search-js-web";
function useConfirmAddress(optionsArg = {}) {
  const formRef = useRef5(null);
  return useMemo4(() => {
    return {
      formRef,
      showConfirm: () => confirmAddress(formRef.current, optionsArg)
    };
  }, [formRef, optionsArg]);
}
export {
  AddressAutofill,
  AddressMinimap,
  SearchBox,
  config,
  useConfirmAddress,
  useEvented,
  useMapboxAutofill,
  useMapboxSearch,
  useSearchSession
};
//# sourceMappingURL=index-esm.js.map
