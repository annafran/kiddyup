{
  "version": 3,
  "sources": ["../src/search/constants.ts", "../src/LngLat.ts", "../src/LngLatBounds.ts", "../src/utils/uuid.ts", "../src/SessionToken.ts", "../src/MapboxError.ts", "../src/fetch.ts", "../src/utils/queryParams.ts", "../src/search/MapboxSearch.ts", "../src/autofill/constants.ts", "../src/autofill/MapboxAutofill.ts", "../src/types.ts", "../src/utils/Evented.ts", "../src/utils/debounce.ts", "../src/SearchSession.ts", "../src/featureToSuggestion.ts", "../src/validate/constants.ts", "../src/validate/MapboxValidate.ts"],
  "sourcesContent": ["export const SEARCH_URL = `https://api.mapbox.com/search/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\nexport const ENDPOINT_FORWARD = 'forward';\nexport const ENDPOINT_REVERSE = 'reverse';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n\nexport const FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;\nexport const PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;\n\nexport const REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;\nexport const PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`;\n", "/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n * These coordinates use longitude, latitude coordinate order (as opposed to latitude, longitude)\n * to match the [GeoJSON specification](https://datatracker.ietf.org/doc/html/rfc7946#section-4),\n * which is equivalent to the OGC:CRS84 coordinate reference system.\n *\n * Note that any method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @class LngLat\n * @param lng - Longitude, measured in degrees.\n * @param lat - Latitude, measured in degrees.\n * @example\n * ```typescript\n * const ll = new LngLat(-123.9749, 40.7736);\n * console.log(ll.lng); // = -123.9749\n * ```\n */\nexport class LngLat {\n  /**\n   * @name lng\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lng: number;\n  /**\n   * @name lat\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lat: number;\n\n  constructor(lng: number, lat: number) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\n        'Invalid LngLat latitude value: must be between -90 and 90'\n      );\n    }\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\n        'Invalid LngLat longitude value: must be between -180 and 180'\n      );\n    }\n  }\n\n  /**\n   * Returns the coordinates represented as an array of two numbers.\n   *\n   * @returns The coordinates represeted as an array of longitude and latitude.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toArray(); // = [-73.9749, 40.7736]\n   * ```\n   */\n  toArray(): [number, number] {\n    return [this.lng, this.lat];\n  }\n\n  /**\n   * Returns the coordinates represent as a string.\n   *\n   * @returns The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n   * ```\n   */\n  toString(): string {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n\n  /**\n   * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n   * to a `LngLat` object.\n   *\n   * If a `LngLat` object is passed in, the function returns a copy.\n   *\n   * @param input - An array of two numbers or object to convert, or a `LngLat` object to return.\n   * @returns A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n   * @example\n   * ```typescript\n   * const arr = [-73.9749, 40.7736];\n   * const ll = LngLat.convert(arr);\n   * console.log(ll);   // = LngLat {lng: -73.9749, lat: 40.7736}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLat\n      | { lng: number; lat: number }\n      | { lon: number; lat: number }\n      | [number, number]\n  ): LngLat {\n    // Make a copy if already an LngLat.\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n\n    if (\n      !Array.isArray(input) &&\n      typeof input == 'object' &&\n      input !== null &&\n      ('lng' in input || 'lon' in input) &&\n      'lat' in input\n    ) {\n      return new LngLat(\n        Number('lng' in input ? input.lng : input.lon),\n        Number(input.lat)\n      );\n    }\n\n    throw new Error(\n      '`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef LngLatLike\n * @type {LngLat | [number, number] | { lng: number, lat: number } | { lon: number, lat: number }}\n * @example\n * ```typescript\n * const v1 = new LngLat(-122.420679, 37.772537);\n * const v2 = [-122.420679, 37.772537];\n * const v3 = {lon: -122.420679, lat: 37.772537};\n * ```\n */\nexport type LngLatLike =\n  | LngLat\n  | { lng: number; lat: number }\n  | { lon: number; lat: number }\n  | [number, number];\n", "import { LngLat, LngLatLike } from './LngLat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * Note that any method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @class LngLatBounds\n */\nexport class LngLatBounds {\n  private _ne: LngLat;\n  private _sw: LngLat;\n\n  /**\n   * @param sw - The southwest corner of the bounding box.\n   * @param ne - The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const sw = new LngLat(-73.9876, 40.7661);\n   * const ne = new LngLat(-73.9397, 40.8002);\n   * const llb = new LngLatBounds(sw, ne);\n   * ```\n   */\n  constructor(sw: LngLatLike, ne: LngLatLike) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n\n  /**\n   * Returns the southwest corner of the bounding box.\n   *\n   * @returns The southwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthWest(); // LngLat {lng: -73.9876, lat: 40.7661}\n   * ```\n   */\n  getSouthWest(): LngLat {\n    return this._sw;\n  }\n\n  /**\n   * Returns the northeast corner of the bounding box.\n   *\n   * @returns The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthEast(); // LngLat {lng: -73.9397, lat: 40.8002}\n   * ```\n   */\n  getNorthEast(): LngLat {\n    return this._ne;\n  }\n\n  /**\n   * Returns the northwest corner of the bounding box. This is commonly used\n   * as the 'min' point in the bounding box.\n   *\n   * @returns The northwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthWest(); // LngLat {lng: -73.9876, lat: 40.8002}\n   * ```\n   */\n  getNorthWest(): LngLat {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n\n  /**\n   * Returns the southeast corner of the bounding box. This is commonly used\n   * as the 'max' point in the bounding box.\n   *\n   * @returns The southeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthEast(); // LngLat {lng: -73.9397, lat: 40.7661}\n   * ```\n   */\n  getSouthEast(): LngLat {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n\n  /**\n   * Returns the west edge of the bounding box.\n   *\n   * @returns The west edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getWest(); // -73.9876\n   * ```\n   */\n  getWest(): number {\n    return this._sw.lng;\n  }\n\n  /**\n   * Returns the south edge of the bounding box.\n   *\n   * @returns The south edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouth(); // 40.7661\n   * ```\n   */\n  getSouth(): number {\n    return this._sw.lat;\n  }\n\n  /**\n   * Returns the east edge of the bounding box.\n   *\n   * @returns The east edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getEast(); // -73.9397\n   * ```\n   */\n  getEast(): number {\n    return this._ne.lng;\n  }\n\n  /**\n   * Returns the north edge of the bounding box.\n   *\n   * @returns The north edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorth(); // 40.8002\n   * ```\n   */\n  getNorth(): number {\n    return this._ne.lat;\n  }\n\n  /**\n   * Returns the bounding box represented as an array.\n   *\n   * @returns The bounding box represented as an array, consisting of the\n   *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n   * ```\n   */\n  toArray(): [[number, number], [number, number]] {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n\n  /**\n   * Returns the bounding box represented as a flattened array.\n   *\n   * @returns The bounding box represented as an array of numbers in [west, south, east, north] order.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toFlatArray(); // = [-73.9876, 40.7661, -73.9397, 40.8002]\n   * ```\n   */\n  toFlatArray(): [number, number, number, number] {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n\n  /**\n   * Return the bounding box represented as a string.\n   *\n   * @returns The bounding box represents as a string of the format\n   *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n   * ```\n   */\n  toString(): string {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n\n  /**\n   * Converts an array to a `LngLatBounds` object.\n   *\n   * If a `LngLatBounds` object is passed in, the function returns a copy.\n   *\n   * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n   *\n   * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.\n   * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n   * @example\n   * ```typescript\n   * const arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n   * const llb = LngLatBounds.convert(arr);\n   * console.log(llb);   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLatBounds\n      | [LngLatLike, LngLatLike]\n      | [number, number, number, number]\n  ): LngLatBounds {\n    if (!input) {\n      throw new Error('Invalid LngLatBounds convert value: falsy');\n    }\n\n    // Make a copy if already an LngLatBounds.\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(\n        LngLat.convert(input[0]),\n        LngLat.convert(input[1])\n      );\n    }\n\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(\n        LngLat.convert([input[0], input[1]]),\n        LngLat.convert([input[2], input[3]])\n      );\n    }\n\n    throw new Error(\n      '`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef LngLatBoundsLike\n * @type {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]}\n * @example\n * ```typescript\n * const v1 = new LngLatBounds(\n *   new LngLat(-73.9876, 40.7661),\n *   new LngLat(-73.9397, 40.8002)\n * );\n * const v2 = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n * const v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n * ```\n */\nexport type LngLatBoundsLike =\n  | LngLatBounds\n  | [LngLatLike, LngLatLike]\n  | [number, number, number, number];\n", "const UUID_RE =\n  /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/**\n * Validates the UUID v4.\n * @param id - UUID value.\n */\nexport function validateUUID(id: string): boolean {\n  return UUID_RE.test(id);\n}\n\n/**\n * Generates a RFC4122 v4 UUID (pseudo-randomly-based)\n *\n * IMPORTANT: THIS IS NOT CRYPTO-GRAPHICALLY SECURE!\n *\n * Since we're using this to generate a random UUID, essentially as an SKU,\n * we don't need to worry about the randomness of the values as much.\n */\nexport function generateUUID(): string {\n  const randomString =\n    Date.now().toString(16) +\n    Math.random().toString(16) +\n    Math.random().toString(16);\n\n  const uuidString = randomString.replace(/\\./g, '');\n\n  const uuid = [\n    uuidString.slice(0, 8),\n    uuidString.slice(8, 12),\n    '4' + uuidString.slice(12, 15) + '-8' + uuidString.slice(15, 18),\n    uuidString.slice(18, 30)\n  ].join('-');\n\n  return uuid;\n}\n", "import { generateUUID } from './utils/uuid';\n\n/**\n * A `SessionToken` object is a unique identifier that groups together `suggest` / `retrieve` calls as part of the\n * [Mapbox Search API](https://docs.mapbox.com/api/search/search/#retrieve-a-suggestion).\n *\n * Session tokens are used for [billing](https://docs.mapbox.com/api/search/search/#search-api-pricing) and\n * customer-accessible analytics.\n *\n * A [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value is recommended,\n * and is generated if an `id` is not provided.\n *\n * Note that any method that accepts a `SessionToken` object as an argument or option\n * can also accept a unique `string` and will perform an implicit conversion.\n * This flexible type is documented as {@link SessionTokenLike}.\n *\n * @name SessionToken\n * @example\n * ```typescript\n * const token = new SessionToken();\n * console.log(token.id); // = I am a UUIDv4 value!\n * ```\n */\nexport class SessionToken {\n  /**\n   * The session token in string format.\n   */\n  readonly id: string;\n\n  constructor(id?: string) {\n    this.id = id ?? generateUUID();\n  }\n\n  /**\n   * Returns the session token in string format.\n   *\n   * This is the same as calling `token.id`, and is okay to be used for serialization.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Converts a string to a `SessionToken` object.\n   *\n   * If a `SessionToken` object is passed in, the function returns a copy.\n   */\n  static convert(token: SessionToken | string): SessionToken {\n    return new SessionToken(\n      token instanceof SessionToken ? token.id : token.toString()\n    );\n  }\n}\n\n/**\n * A {@link SessionToken} object or string representing a Mapbox Search API session token.\n *\n * It's recommended this value is a [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value.\n *\n * @typedef SessionTokenLike\n * @type {SessionToken | string}\n * @example\n * const v1 = new SessionToken();\n * const v2 = new SessionToken('f06e7531-6373-4d5a-8614-b6f313488050');\n * const v3 = 'f06e7531-6373-4d5a-8614-b6f313488050';\n */\nexport type SessionTokenLike = string | SessionToken;\n", "export const UNKNOWN_ERROR = 'Unknown error';\n\n/**\n * Thrown from Search JS Core functions when a network request fails.\n *\n * See common errors here:\n * - [MapboxSearch](https://docs.mapbox.com/api/search/search/#search-api-errors)\n * - [MapboxAutofill](https://docs.mapbox.com/api/search/geocoding/#geocoding-api-errors)\n */\nexport class MapboxError extends Error {\n  readonly statusCode: number;\n\n  constructor(json: Record<string, unknown>, statusCode: number) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = 'MapboxError';\n    this.statusCode = statusCode;\n  }\n\n  /**\n   * Modified Error toString() method to include the status code.\n   */\n  toString(): string {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n}\n\n/**\n * Utility function to see if the result is \"ok\" (in 200 range).\n *\n * If not, throw a {@link MapboxError} filled out by the\n * [JSON error format](https://docs.mapbox.com/api/search/search/#search-api-errors).\n */\nexport async function handleNonOkRes(res: Response): Promise<void> {\n  if (!res.ok) {\n    const json = await res.json();\n    throw new MapboxError(json, res.status);\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// GLOBALS\nlet _fetchImpl: typeof fetch = globalThis.fetch;\nlet _abortControllerImpl: typeof AbortController = globalThis.AbortController;\n\ninterface FetchImplementation {\n  fetch: typeof fetch;\n  AbortController: typeof AbortController;\n}\n\n/**\n * Polyfills {@link fetch} implementation used in Search JS Core.\n *\n * If a `fetch` implementation is already available, the polyfill will be\n * silently ignored.\n *\n * When running Search JS Core in a Node.js environment, fetch must be either\n * polyfilled globally or passed into this function before usage of\n * internal library functionality.\n *\n * @param opts Options for the polyfill.\n * @param {fetch} opts.fetch Required. A custom `fetch` implementation.\n * @param {AbortController} opts.AbortController Required. A custom `AbortController` implementation.\n * @param {boolean} force If `true`, the polyfill will be forced to load. Otherwise, it will only load if `fetch` is not available.\n */\nexport function polyfillFetch(\n  { fetch, AbortController }: FetchImplementation,\n  force = false\n): void {\n  if (!fetch) {\n    throw new Error(\n      'Fetch implementation must include implementations of `fetch`.'\n    );\n  }\n\n  if (_fetchImpl && !force) {\n    return;\n  }\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\n\n/**\n * Returns the {@link FetchImplementation} used by Search JS Core.\n */\nexport function getFetch(): FetchImplementation {\n  if (!_fetchImpl) {\n    throw new Error(\n      'Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.'\n    );\n  }\n\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n", "type Primitive = string | number | boolean | null;\n\n/**\n * tl;dr - [classnames](https://www.npmjs.com/package/classnames) for query parameters.\n *\n * Encodes query parameters into a stringified form, good for use with {@link URL#search}.\n * Objects are key-value pairs, and if a falsy object is passed, it will be omitted.\n *\n * Null and undefined values are ignored.\n * Array values are encoded as comma-separated values.\n *\n * @example\n * ```typescript\n * const limit = 0;\n * const offset = null;\n * const params = queryParams(\n *  {\n *    q: 'pizza',\n *    c: null\n *  },\n *  (limit != null) && { limit },\n *  (offset != null) && { offset }\n * );\n * console.log(params); // = 'q=pizza&limit=0'\n * ```\n */\nexport function queryParams<T extends Record<string, Primitive>>(\n  ...objects: (T | false)[]\n): string {\n  const params = [];\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    const entries = Object.entries(obj);\n    for (const [key, value] of entries) {\n      if (value == null) continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n\n  return params.join('&');\n}\n", "import {\n  ENDPOINT_RETRIEVE,\n  ENDPOINT_SUGGEST,\n  FORWARD_URL,\n  PERMANENT_FORWARD_URL,\n  PERMANENT_REVERSE_URL,\n  RETRIEVE_URL,\n  REVERSE_URL,\n  SUGGEST_URL\n} from './constants';\nimport {\n  AdministrativeUnitTypes,\n  Suggestion,\n  FeatureSuggestion\n} from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism works in the same way as the [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests\n   * together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef Options\n */\nexport interface Options {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * The navigation routing profile to use for distance/eta calculations.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  navigation_profile?: 'driving' | 'walking' | 'cycling';\n  /**\n   * The location from which to calculate distance. **This parameter may incur additional latency.**\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  origin: string | LngLatLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n  /**\n   * Used to estimate the time of arrival from {@link Options#origin}. **This parameter may incur additional latency.**\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  eta_type?: 'navigation';\n  /**\n   * Limit results to one or more types of features. If no types are specified, all possible types may be returned.\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#administrative-unit-types\n   */\n  types?: string | Set<AdministrativeUnitTypes>;\n}\n\ninterface PermanentOptions {\n  /**\n   * The permanent endpoints are used for use cases that require storing\n   * position data. If 'true', the permanent endpoints will be used, which are\n   * billed separately.\n   *\n   * If you're interested in using {@link PermanentOptions#permanent}, contact\n   * [Mapbox sales](https://www.mapbox.com/contact/sales/).\n   *\n   * It's important to speak with an Account Manager on the Sales team prior to making requests\n   * with {@link PermanentOptions#permanent} set to `true`, as unsuccessful requests\n   * made by an account that does not have access to the endpoint may be billable.\n   */\n  permanent: boolean;\n}\n\n/**\n * @typedef SuggestionResponse\n */\nexport interface SuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: Suggestion[];\n}\n\n/**\n * @typedef RetrieveResponse\n */\nexport interface RetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: FeatureSuggestion[];\n}\n\n/**\n * A `MapboxSearch` object is an application's main entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/).\n *\n * `MapboxSearch` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxSearch#suggest}: The user enters a search term, and a list of suggested results is returned with\n *      optional data such as: eta, distance calculations, etc.\n *   2. {@link MapboxSearch#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned for displaying on a map or otherwise manipulating.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxSearch`, and\n * other options may be specified either in the constructor or in the {@link MapboxSearch#suggest} call.\n *\n * @class MapboxSearch\n * @param {Options} [options]\n * @param {string} [options.accessToken]\n *\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n *\n * const sessionToken = new SessionToken();\n * const result = await search.suggest('Washington D.C.', { sessionToken });\n * if (result.suggestions.length === 0) return;\n *\n * const suggestion = result.suggestions[0];\n * if (search.canRetrieve(suggestion)) {\n *  const { features } = await search.retrieve(suggestion, { sessionToken });\n *  doSomethingWithCoordinates(features);\n * } else if (search.canSuggest(suggestion)) {\n *   // .. go through suggest flow again ..\n * }\n * ```\n */\nexport class MapboxSearch {\n  static defaults: Partial<Options> = {\n    language: 'en'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link Options}) to be merged into options in the following methods:\n   * - {@link MapboxSearch#suggest}\n   * - {@link MapboxSearch#forward}\n   * - {@link MapboxSearch#reverse}\n   */\n  defaults: Partial<Options>;\n\n  constructor(options: Partial<AccessTokenOptions & Options> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxSearch.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Interactive search} */\n\n  /**\n   * {@link MapboxSearch#suggest} is \"part one\" of the two-step interactive search experience, and includes\n   * useful information such as: {@link Suggestion#feature_name}, {@link Suggestion#description}, and {@link Suggestion#maki}.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * It may be useful to call {@link MapboxSearch#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link MapboxSearch#canSuggest}, and further calls to {@link MapboxSearch#suggest}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {string} searchText\n   * @param {Options} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & Options>\n  ): Promise<SuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n      throw new Error(\n        'to provide eta estimate: eta, navigation_profile, and origin are required'\n      );\n    }\n    if (options.origin && !options.navigation_profile) {\n      throw new Error(\n        'to provide distance estimate: both navigation_profile and origin are required'\n      );\n    }\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as SuggestionResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link MapboxSearch#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * feature suggestions should come from the {@link MapboxSearch#forward} method\n   * with {@link PermanentOptions#permanent} enabled.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {any} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<RetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(RETRIEVE_URL);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      ...this.#getFetchInfo(suggestion),\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_RETRIEVE;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_SUGGEST;\n  }\n\n  /** @section {Programmatic search} */\n\n  /**\n   * {@link MapboxSearch#forward} is our programmatic one-step search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async forward(\n    searchText: string,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#reverse} allows you to look up a geographic coordinate pair\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param lngLat - Either a {@link LngLatLike} object or string in 'lng,lat' comma-separated format.\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async reverse(\n    lngLat: string | LngLatLike,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!lngLat) {\n      throw new Error('lngLat is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const searchText =\n      typeof lngLat === 'string'\n        ? lngLat\n        : LngLat.convert(lngLat).toArray().join(',');\n\n    const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxSearch#suggest} and\n   * {@link MapboxSearch#forward}.\n   */\n  #getQueryParams(options: Partial<Options & SessionTokenOptions>): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit,\n        navigation_profile: options.navigation_profile,\n        eta_type: options.eta_type\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.origin && {\n        origin:\n          typeof options.origin === 'string'\n            ? options.origin\n            : LngLat.convert(options.origin).toArray().join(',')\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n  }\n\n  /**\n   * Gets a partial fetch request from this suggestion's action.\n   */\n  #getFetchInfo(suggestion: Suggestion): Partial<RequestInit> {\n    if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n      throw new Error('Suggestion cannot be retrieved or suggested');\n    }\n\n    const action = suggestion.action;\n    const body = JSON.stringify(action.body);\n\n    return {\n      method: action.method,\n      body,\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': body.length.toString()\n      }\n    };\n  }\n}\n", "export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n", "import { RETRIEVE_URL, SUGGEST_URL } from './constants';\nimport { AutofillSuggestion, AutofillFeatureSuggestion } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef AutofillOptions\n */\nexport interface AutofillOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link AutofillOptions#proximity} and {@link AutofillOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef AutofillSuggestionResponse\n */\nexport interface AutofillSuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: AutofillSuggestion[];\n}\n\n/**\n * @typedef AutofillRetrieveResponse\n */\nexport interface AutofillRetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: AutofillFeatureSuggestion[];\n}\n\n/**\n * A `MapboxAutofill` object is an application's main entrypoint to the\n * Mapbox Autofill API. The Mapbox Autofill API is an API similar to {@link MapboxSearch},\n * but targeted towards **address** autocomplete.\n *\n * Only address types are returned by the API.\n *\n * `MapboxAutofill` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxAutofill#suggest}: The user enters a search term, and a list of suggested results is returned with\n *     address data.\n *   2. {@link MapboxAutofill#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxAutofill`, and\n * other options may be specified either in the constructor or in the {@link MapboxAutofill#suggest} call.\n *\n * @class MapboxAutofill\n * @param {AutofillOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxAutofill {\n  static defaults: Partial<AutofillOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link AutofillOptions}) to be merged into options in the following methods:\n   * - {@link MapboxAutofill#suggest}\n   *\n   * @type {AutofillOptions}\n   */\n  defaults: Partial<AutofillOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & AutofillOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxAutofill.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxAutofill#suggest} is \"part one\" of the two-step autofill experience, and includes\n   * autofill information.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & AutofillOptions>\n  ): Promise<AutofillSuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillSuggestionResponse;\n\n    // Add 'original_search_text' so we can retrieve.\n    return {\n      ...json,\n      suggestions: json.suggestions.map((suggestion) => {\n        return {\n          ...suggestion,\n          original_search_text: searchText\n        };\n      })\n    };\n  }\n\n  /**\n   * {@link MapboxAutofill#retrieve} is \"part two\" of the two-step autofill experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link AutofillSuggestion} returned from \"part one,\"\n   * {@link MapboxAutofill#suggest}.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: AutofillSuggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<AutofillRetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(`${RETRIEVE_URL}/${suggestion.action.id}`);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), { signal });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillRetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxAutofill#suggest}\n   */\n  #getQueryParams(\n    options: Partial<AutofillOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n\n  /**\n   * Returns true if {@link MapboxAutofill#retrieve} can be called on this suggestion,\n   * false otherwise.\n   */\n  canRetrieve(suggestion: AutofillSuggestion): boolean {\n    const action = suggestion.action;\n\n    return typeof action?.id === 'string';\n  }\n}\n", "/**\n * @typedef MatchCodeConfidence\n */\nexport const enum MatchCodeConfidence {\n  /**\n   * An exact match.\n   */\n  exact = 'exact',\n  /**\n   * High confidence of a match.\n   */\n  high = 'high',\n  /**\n   * Medium confidence of a match.\n   */\n  medium = 'medium',\n  /**\n   * Low confidence of a match.\n   */\n  low = 'low'\n}\n\n/**\n * An object describing the level of confidence that the given response feature matches the address intended by the request query.\n * Includes boolean flags denoting matches for each address sub-component.\n *\n * @typedef MatchCode\n */\nexport interface MatchCode {\n  /**\n   * A measure of confidence that the returned feature suggestion matches the intended address, based on the search text provided.\n   */\n  confidence: MatchCodeConfidence;\n  /**\n   * True if the confidence value is \"exact\".\n   */\n  exact_match: boolean;\n  /**\n   * True if the house number component was matched.\n   */\n  house_number: boolean;\n  /**\n   * True if the street component was matched.\n   */\n  street: boolean;\n  /**\n   * True if the postcode was matched.\n   */\n  postcode: boolean;\n  /**\n   * True if the place component was matched.\n   */\n  place: boolean;\n  /**\n   * True if the region component was matched.\n   */\n  region?: boolean;\n  /**\n   * True if the locality component was matched.\n   */\n  locality?: boolean;\n}\n", "/**\n * `Evented` mixes methods into other classes for event capabilities.\n *\n * If you are an end-user, you will most likely use these methods through\n * classes like {@link SearchSession}.\n *\n * For lists of events you can listen for, see API documentation for\n * specific classes.\n *\n * @class Evented\n */\nexport class Evented<T> {\n  #listeners: Partial<{\n    [key in keyof T]: ((arg0: T[key]) => void)[];\n  }> = {};\n\n  /**\n   * Adds a listener to a specified event type.\n   *\n   * @param type - The event type to add a listen for.\n   * @param listener - The function to be called when the event is fired.\n   */\n  addEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // Create listener if doesn't already exist.\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n\n    listenersArr[type].push(listener);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   *\n   * @param type - The event type to remove listeners for.\n   * @param listener - The listener function to remove.\n   */\n  removeEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fire<K extends keyof T>(type: K, arg0: T[K]): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n}\n", "/**\n * Version of the classic `debounce` function that accepts a `signalFn`\n * argument, which can return an {@link AbortSignal}.\n */\nexport function debounce<F extends (...args: unknown[]) => unknown>(\n  func: F,\n  wait: number,\n  signalFn?: () => AbortSignal\n): F {\n  let timeout = null;\n\n  return ((...args: Parameters<F>) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (signal?.aborted) {\n        return;\n      }\n      func(...args);\n    }, wait);\n  }) as F;\n}\n", "/* eslint-disable prefer-const */\nimport { SessionToken, SessionTokenLike } from './SessionToken';\n\nimport { getFetch } from './fetch';\n\nimport { Evented } from './utils/Evented';\nimport { debounce } from './utils/debounce';\n\n/**\n * Shortcut function to create a new AbortController from the polyfill.\n */\nfunction createAbortController(): AbortController {\n  const { AbortController } = getFetch();\n  return new AbortController();\n}\n\ninterface EventTypes<SuggestionResponse, RetrieveResponse> {\n  suggest: SuggestionResponse;\n  suggesterror: Error;\n  retrieve: RetrieveResponse;\n}\n\n/**\n * TypeScript magic section: what is this?\n *\n * Despite the name {@link SearchSession}, in Search JS Web we use it to control\n * both {@link MapboxSearch} **and** {@link MapboxAutofill} instances. Both\n * of these have similar workflows, but are separate APIs with different options\n * and responses.\n *\n * In order to make TypeScript happy, this type is an \"approximation\" of what\n * {@link SearchSession} uses. When you construct a new {@link SearchSession},\n * because of this type [Options, Suggestion, SuggestionResponse, RetrieveResponse]\n * are automatically inferred.\n *\n * @internal\n * @example\n * ```typescript\n * const autofill = new MapboxAutofill({\n *  accessToken: 'pk.my-fancy-token',\n * });\n *\n * const session = new SearchSession(autofill);\n *\n * `session` has inferred type = SearchSession<\n *   AutofillOptions,\n *   AutofillSuggestion,\n *   AutofillSuggestionResponse,\n *   AutofillRetrieveResponse\n * >\n * ```\n */\ntype SuggestSearch<Options, Suggestion, SuggestionResponse, RetrieveResponse> =\n  {\n    suggest: (\n      text: string,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n        signal: AbortSignal;\n      }\n    ) => Promise<SuggestionResponse>;\n    retrieve: (\n      suggestion: Suggestion,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n      }\n    ) => Promise<RetrieveResponse>;\n    canRetrieve?: (suggestion: Suggestion) => boolean;\n    canSuggest?: (suggestion: Suggestion) => boolean;\n  };\n\n/**\n * A `SearchSession` object is a managed entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/)\n * or Mapbox Autocomplete API.\n *\n * `SearchSession` abstracts the suggest/retrieve flow of the two-step interactive search experience.\n *\n * Compared to using these APIs directly, you can use a `SearchSession` to:\n * 1. Automatically manage the session token lifecycle.\n * 2. Debounce calls to {@link SearchSession#suggest}.\n * 2. Abort in-flight requests with an imperative API.\n *\n * @class SearchSession\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n * const session = new SearchSession(search);\n *\n * session.addEventListener('suggest', (res) => {\n *   presentResultsToUser(res.suggestions);\n * });\n *\n * session.addEventListener('retrieve', (res) => {\n *   doSomethingWithFeatureCollection(res);\n * });\n *\n * document.querySelector('button').addEventListener('click', (event) => {\n *   const suggestions = session.suggestions?.suggestions;\n *   if (!suggestions || !suggestions.length) {\n *     return;\n *   }\n *\n *   const suggestion = suggestions[0];\n *   if (session.canRetrieve(suggestion)) {\n *     session.retrieve(suggestion);\n *   } else if (session.canSuggest(suggestion)) {\n *     // .. go through suggest flow again ..\n *     session.suggest(suggestion.text);\n *   }\n * });\n *\n * session.suggest('Washington D.C.');\n * ```\n * @param {MapboxSearch | MapboxAutofill} search - The search interface to wrap.\n * @param {number} wait - The time in milliseconds to wait before sending a new request to the {@link SearchSession#suggest} call.\n */\nexport class SearchSession<\n  Options,\n  Suggestion,\n  SuggestionResponse,\n  RetrieveResponse\n> extends Evented<EventTypes<SuggestionResponse, RetrieveResponse>> {\n  readonly search: SuggestSearch<\n    Options,\n    Suggestion,\n    SuggestionResponse,\n    RetrieveResponse\n  >;\n\n  /**\n   * The time in milliseconds to wait before sending a new request to the\n   * {@link SearchSession#suggest} call.\n   */\n  readonly debounce: number;\n\n  /**\n   * The session token is an SKU (billing token) used to identify the current\n   * search session and provide analytics to the customer.\n   *\n   * As per {@link SessionToken}, this is a UUIDv4 value.\n   *\n   */\n  sessionToken = new SessionToken();\n\n  #suggestions: SuggestionResponse | null;\n\n  /**\n   * The suggestions from the last successful suggest call, if any.\n   */\n  get suggestions(): SuggestionResponse | null {\n    return this.#suggestions;\n  }\n\n  constructor(\n    search: SuggestSearch<\n      Options,\n      Suggestion,\n      SuggestionResponse,\n      RetrieveResponse\n    >,\n    wait = 0\n  ) {\n    super();\n\n    // Set 'suggest' method using debounce.\n    this.#suggestDebounce = debounce(\n      async (\n        searchText: string,\n        options: Partial<Options> = {}\n      ): Promise<void> => {\n        // Refresh abort controller.\n        this.#abort.abort();\n        this.#abort = createAbortController();\n\n        if (!searchText) {\n          this.#suggestions = null;\n          this.fire('suggest', this.#suggestions);\n          return;\n        }\n\n        try {\n          const res = await this.search.suggest(searchText, {\n            sessionToken: this.sessionToken,\n            ...options,\n            signal: this.#abort.signal\n          });\n\n          this.#suggestions = res;\n          this.fire('suggest', res);\n        } catch (err) {\n          if (err.name === 'AbortError') {\n            return;\n          }\n\n          this.fire('suggesterror', err);\n        }\n      },\n      wait,\n      () => this.#abort.signal\n    );\n\n    /**\n     * Define properties using {@link Object#defineProperties} so they are readonly during runtime,\n     * not just in TypeScript.\n     */\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n\n  /**\n   * The {@link AbortController} is used to abort the current suggest, either\n   * because of a new {@link SearchSession#suggest} call, or because\n   * of {@link SearchSession#abort}.\n   *\n   * In both of these cases, a new {@link AbortController} is created,\n   * and the old one is aborted.\n   */\n  #abort = createAbortController();\n\n  #suggestDebounce: (searchText: string, options?: Partial<Options>) => void;\n\n  /** @section {Methods} */\n\n  /**\n   * {@link SearchSession#suggest} is \"part one\" of the two-step interactive search experience,\n   * and each suggestion includes metadata to present to the user.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link SearchSession#retrieve}.\n   *\n   * It may be useful to call {@link SearchSession#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link SearchSession#canSuggest}, and further calls to {@link SearchSession#suggest}.\n   *\n   * Results can be retrieved with the \"suggest\" event.\n   *\n   * @example\n   * ```typescript\n   * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n   * const session = new SearchSession(search);\n   *\n   * session.addEventListener('suggest', (res) => {\n   *   presentResultsToUser(res.suggestions);\n   * });\n   *\n   * session.suggest('Washington D.C.');\n   * ```\n   */\n  suggest(\n    searchText: string,\n    options?: Partial<Options>\n  ): Promise<SuggestionResponse> {\n    this.#suggestDebounce(searchText, options);\n\n    return new Promise((resolve, reject) => {\n      let suggestFn: (val: SuggestionResponse) => void;\n      let suggestErrorFn: (val: Error) => void;\n\n      suggestFn = (res) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        resolve(res);\n      };\n      suggestErrorFn = (err) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        reject(err);\n      };\n\n      this.addEventListener('suggest', suggestFn);\n      this.addEventListener('suggesterror', suggestErrorFn);\n    });\n  }\n\n  /**\n   * Clears the current suggestions.\n   */\n  clear(): void {\n    this.suggest('');\n  }\n\n  /**\n   * {@link SearchSession#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link SearchSession#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, results should not be stored in a customer database.\n   * Results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    options?: Partial<Options>\n  ): Promise<RetrieveResponse> {\n    const res = await this.search.retrieve(suggestion, {\n      sessionToken: this.sessionToken,\n      ...options\n    });\n\n    this.fire('retrieve', res);\n    return res;\n  }\n\n  /**\n   * Returns true if {@link SearchSession#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n\n    return this.search.canRetrieve(suggestion);\n  }\n\n  /**\n   * Returns true if {@link SearchSession#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n\n    return this.search.canSuggest(suggestion);\n  }\n\n  /**\n   * Aborts the current {@link SearchSession#suggest} request.\n   */\n  abort(): void {\n    this.#abort.abort();\n    this.#abort = createAbortController();\n  }\n}\n", "import { FeatureSuggestion, Suggestion } from './search/types';\nimport {\n  AutofillFeatureSuggestion,\n  AutofillSuggestion\n} from './autofill/types';\n\nfunction featureToSuggestion(feature: FeatureSuggestion): Suggestion;\n\nfunction featureToSuggestion(\n  feature: AutofillFeatureSuggestion\n): AutofillSuggestion;\n\n/**\n * Utility function to convert the {@link FeatureSuggestion} properties to a\n * {@link Suggestion} object.\n */\nfunction featureToSuggestion(\n  feature: FeatureSuggestion | AutofillFeatureSuggestion\n): Suggestion | Omit<AutofillSuggestion, 'original_search_text' | 'action'> {\n  const { properties } = feature;\n  return {\n    ...properties\n  };\n}\n\nexport { featureToSuggestion };\n", "export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_VALIDATE = 'retrieve';\n\nexport const VALIDATE_URL = `${SEARCH_URL}/${ENDPOINT_VALIDATE}`;\n", "import { VALIDATE_URL } from './constants';\nimport { ValidateFeature } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef ValidateOptions\n */\nexport interface ValidateOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link ValidateOptions#proximity} and {@link ValidateOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef ValidateResponse\n */\nexport interface ValidateResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: ValidateFeature[];\n}\n\n/**\n * A `MapboxValidate` object is an application's main entrypoint to the\n * Mapbox Validate API. The Mapbox Validate API is an API similar to {@link MapboxAutofill},\n * but targeted at checking **address**.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxValidate`, and\n * other options may be specified either in the constructor or in the {@link MapboxValidate#validate} call.\n *\n * @class MapboxValidate\n * @param {ValidateOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxValidate {\n  static defaults: Partial<ValidateOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link ValidateOptions}) to be merged into options in the following methods:\n   * - {@link ValidateOptions#validate}\n   *\n   * @type {ValidateOptions}\n   */\n  defaults: Partial<ValidateOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & ValidateOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxValidate.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxValidate#validate} allows you to validate an address\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {String} searchText\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async validate(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<ValidateResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as ValidateResponse;\n\n    if (json.features.length > 0) {\n      json.features = [json.features[0]];\n    }\n\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxValidate#validate}\n   */\n  #getQueryParams(\n    options: Partial<ValidateOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
