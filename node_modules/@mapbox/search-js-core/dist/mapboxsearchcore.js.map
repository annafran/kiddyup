{
  "version": 3,
  "sources": ["../src/index.ts", "../src/search/constants.ts", "../src/LngLat.ts", "../src/LngLatBounds.ts", "../src/utils/uuid.ts", "../src/SessionToken.ts", "../src/MapboxError.ts", "../src/fetch.ts", "../src/utils/queryParams.ts", "../src/search/MapboxSearch.ts", "../src/autofill/constants.ts", "../src/autofill/MapboxAutofill.ts", "../src/types.ts", "../src/utils/Evented.ts", "../src/utils/debounce.ts", "../src/SearchSession.ts", "../src/featureToSuggestion.ts", "../src/validate/constants.ts", "../src/validate/MapboxValidate.ts"],
  "sourcesContent": ["import {\n  Options,\n  MapboxSearch,\n  SuggestionResponse,\n  RetrieveResponse\n} from './search/MapboxSearch';\nimport {\n  AdministrativeUnitTypes,\n  Suggestion,\n  FeatureSuggestion\n} from './search/types';\n\nimport {\n  AutofillOptions,\n  MapboxAutofill,\n  AutofillSuggestionResponse,\n  AutofillRetrieveResponse\n} from './autofill/MapboxAutofill';\nimport {\n  AutofillSuggestion,\n  AutofillFeatureSuggestion\n} from './autofill/types';\nimport { MatchCodeConfidence, MatchCode } from './types';\nimport { ValidateFeature } from './validate/types';\n\nimport { SearchSession } from './SearchSession';\nimport { SessionToken, SessionTokenLike } from './SessionToken';\nimport { MapboxError } from './MapboxError';\n\nimport { LngLat, LngLatLike } from './LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from './LngLatBounds';\n\nimport { polyfillFetch } from './fetch';\nimport { featureToSuggestion } from './featureToSuggestion';\n\nimport { Evented } from './utils/Evented';\nimport { debounce } from './utils/debounce';\n\nimport {\n  ValidateOptions,\n  MapboxValidate,\n  ValidateResponse\n} from './validate/MapboxValidate';\n\nexport {\n  Options,\n  MapboxSearch,\n  SuggestionResponse,\n  RetrieveResponse,\n  Suggestion,\n  FeatureSuggestion,\n  AutofillOptions,\n  MapboxAutofill,\n  AutofillSuggestionResponse,\n  AutofillRetrieveResponse,\n  AutofillSuggestion,\n  AutofillFeatureSuggestion,\n  MatchCode,\n  MatchCodeConfidence,\n  AdministrativeUnitTypes,\n  SearchSession,\n  SessionToken,\n  SessionTokenLike,\n  MapboxError,\n  LngLat,\n  LngLatLike,\n  LngLatBounds,\n  LngLatBoundsLike,\n  polyfillFetch,\n  featureToSuggestion,\n  Evented,\n  debounce,\n  ValidateOptions,\n  MapboxValidate,\n  ValidateResponse,\n  ValidateFeature\n};\n", "export const SEARCH_URL = `https://api.mapbox.com/search/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\nexport const ENDPOINT_FORWARD = 'forward';\nexport const ENDPOINT_REVERSE = 'reverse';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n\nexport const FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;\nexport const PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;\n\nexport const REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;\nexport const PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`;\n", "/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n * These coordinates use longitude, latitude coordinate order (as opposed to latitude, longitude)\n * to match the [GeoJSON specification](https://datatracker.ietf.org/doc/html/rfc7946#section-4),\n * which is equivalent to the OGC:CRS84 coordinate reference system.\n *\n * Note that any method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @class LngLat\n * @param lng - Longitude, measured in degrees.\n * @param lat - Latitude, measured in degrees.\n * @example\n * ```typescript\n * const ll = new LngLat(-123.9749, 40.7736);\n * console.log(ll.lng); // = -123.9749\n * ```\n */\nexport class LngLat {\n  /**\n   * @name lng\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lng: number;\n  /**\n   * @name lat\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lat: number;\n\n  constructor(lng: number, lat: number) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\n        'Invalid LngLat latitude value: must be between -90 and 90'\n      );\n    }\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\n        'Invalid LngLat longitude value: must be between -180 and 180'\n      );\n    }\n  }\n\n  /**\n   * Returns the coordinates represented as an array of two numbers.\n   *\n   * @returns The coordinates represeted as an array of longitude and latitude.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toArray(); // = [-73.9749, 40.7736]\n   * ```\n   */\n  toArray(): [number, number] {\n    return [this.lng, this.lat];\n  }\n\n  /**\n   * Returns the coordinates represent as a string.\n   *\n   * @returns The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n   * ```\n   */\n  toString(): string {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n\n  /**\n   * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n   * to a `LngLat` object.\n   *\n   * If a `LngLat` object is passed in, the function returns a copy.\n   *\n   * @param input - An array of two numbers or object to convert, or a `LngLat` object to return.\n   * @returns A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n   * @example\n   * ```typescript\n   * const arr = [-73.9749, 40.7736];\n   * const ll = LngLat.convert(arr);\n   * console.log(ll);   // = LngLat {lng: -73.9749, lat: 40.7736}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLat\n      | { lng: number; lat: number }\n      | { lon: number; lat: number }\n      | [number, number]\n  ): LngLat {\n    // Make a copy if already an LngLat.\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n\n    if (\n      !Array.isArray(input) &&\n      typeof input == 'object' &&\n      input !== null &&\n      ('lng' in input || 'lon' in input) &&\n      'lat' in input\n    ) {\n      return new LngLat(\n        Number('lng' in input ? input.lng : input.lon),\n        Number(input.lat)\n      );\n    }\n\n    throw new Error(\n      '`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef LngLatLike\n * @type {LngLat | [number, number] | { lng: number, lat: number } | { lon: number, lat: number }}\n * @example\n * ```typescript\n * const v1 = new LngLat(-122.420679, 37.772537);\n * const v2 = [-122.420679, 37.772537];\n * const v3 = {lon: -122.420679, lat: 37.772537};\n * ```\n */\nexport type LngLatLike =\n  | LngLat\n  | { lng: number; lat: number }\n  | { lon: number; lat: number }\n  | [number, number];\n", "import { LngLat, LngLatLike } from './LngLat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * Note that any method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @class LngLatBounds\n */\nexport class LngLatBounds {\n  private _ne: LngLat;\n  private _sw: LngLat;\n\n  /**\n   * @param sw - The southwest corner of the bounding box.\n   * @param ne - The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const sw = new LngLat(-73.9876, 40.7661);\n   * const ne = new LngLat(-73.9397, 40.8002);\n   * const llb = new LngLatBounds(sw, ne);\n   * ```\n   */\n  constructor(sw: LngLatLike, ne: LngLatLike) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n\n  /**\n   * Returns the southwest corner of the bounding box.\n   *\n   * @returns The southwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthWest(); // LngLat {lng: -73.9876, lat: 40.7661}\n   * ```\n   */\n  getSouthWest(): LngLat {\n    return this._sw;\n  }\n\n  /**\n   * Returns the northeast corner of the bounding box.\n   *\n   * @returns The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthEast(); // LngLat {lng: -73.9397, lat: 40.8002}\n   * ```\n   */\n  getNorthEast(): LngLat {\n    return this._ne;\n  }\n\n  /**\n   * Returns the northwest corner of the bounding box. This is commonly used\n   * as the 'min' point in the bounding box.\n   *\n   * @returns The northwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthWest(); // LngLat {lng: -73.9876, lat: 40.8002}\n   * ```\n   */\n  getNorthWest(): LngLat {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n\n  /**\n   * Returns the southeast corner of the bounding box. This is commonly used\n   * as the 'max' point in the bounding box.\n   *\n   * @returns The southeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthEast(); // LngLat {lng: -73.9397, lat: 40.7661}\n   * ```\n   */\n  getSouthEast(): LngLat {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n\n  /**\n   * Returns the west edge of the bounding box.\n   *\n   * @returns The west edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getWest(); // -73.9876\n   * ```\n   */\n  getWest(): number {\n    return this._sw.lng;\n  }\n\n  /**\n   * Returns the south edge of the bounding box.\n   *\n   * @returns The south edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouth(); // 40.7661\n   * ```\n   */\n  getSouth(): number {\n    return this._sw.lat;\n  }\n\n  /**\n   * Returns the east edge of the bounding box.\n   *\n   * @returns The east edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getEast(); // -73.9397\n   * ```\n   */\n  getEast(): number {\n    return this._ne.lng;\n  }\n\n  /**\n   * Returns the north edge of the bounding box.\n   *\n   * @returns The north edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorth(); // 40.8002\n   * ```\n   */\n  getNorth(): number {\n    return this._ne.lat;\n  }\n\n  /**\n   * Returns the bounding box represented as an array.\n   *\n   * @returns The bounding box represented as an array, consisting of the\n   *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n   * ```\n   */\n  toArray(): [[number, number], [number, number]] {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n\n  /**\n   * Returns the bounding box represented as a flattened array.\n   *\n   * @returns The bounding box represented as an array of numbers in [west, south, east, north] order.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toFlatArray(); // = [-73.9876, 40.7661, -73.9397, 40.8002]\n   * ```\n   */\n  toFlatArray(): [number, number, number, number] {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n\n  /**\n   * Return the bounding box represented as a string.\n   *\n   * @returns The bounding box represents as a string of the format\n   *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n   * ```\n   */\n  toString(): string {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n\n  /**\n   * Converts an array to a `LngLatBounds` object.\n   *\n   * If a `LngLatBounds` object is passed in, the function returns a copy.\n   *\n   * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n   *\n   * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.\n   * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n   * @example\n   * ```typescript\n   * const arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n   * const llb = LngLatBounds.convert(arr);\n   * console.log(llb);   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLatBounds\n      | [LngLatLike, LngLatLike]\n      | [number, number, number, number]\n  ): LngLatBounds {\n    if (!input) {\n      throw new Error('Invalid LngLatBounds convert value: falsy');\n    }\n\n    // Make a copy if already an LngLatBounds.\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(\n        LngLat.convert(input[0]),\n        LngLat.convert(input[1])\n      );\n    }\n\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(\n        LngLat.convert([input[0], input[1]]),\n        LngLat.convert([input[2], input[3]])\n      );\n    }\n\n    throw new Error(\n      '`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef LngLatBoundsLike\n * @type {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]}\n * @example\n * ```typescript\n * const v1 = new LngLatBounds(\n *   new LngLat(-73.9876, 40.7661),\n *   new LngLat(-73.9397, 40.8002)\n * );\n * const v2 = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n * const v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n * ```\n */\nexport type LngLatBoundsLike =\n  | LngLatBounds\n  | [LngLatLike, LngLatLike]\n  | [number, number, number, number];\n", "const UUID_RE =\n  /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/**\n * Validates the UUID v4.\n * @param id - UUID value.\n */\nexport function validateUUID(id: string): boolean {\n  return UUID_RE.test(id);\n}\n\n/**\n * Generates a RFC4122 v4 UUID (pseudo-randomly-based)\n *\n * IMPORTANT: THIS IS NOT CRYPTO-GRAPHICALLY SECURE!\n *\n * Since we're using this to generate a random UUID, essentially as an SKU,\n * we don't need to worry about the randomness of the values as much.\n */\nexport function generateUUID(): string {\n  const randomString =\n    Date.now().toString(16) +\n    Math.random().toString(16) +\n    Math.random().toString(16);\n\n  const uuidString = randomString.replace(/\\./g, '');\n\n  const uuid = [\n    uuidString.slice(0, 8),\n    uuidString.slice(8, 12),\n    '4' + uuidString.slice(12, 15) + '-8' + uuidString.slice(15, 18),\n    uuidString.slice(18, 30)\n  ].join('-');\n\n  return uuid;\n}\n", "import { generateUUID } from './utils/uuid';\n\n/**\n * A `SessionToken` object is a unique identifier that groups together `suggest` / `retrieve` calls as part of the\n * [Mapbox Search API](https://docs.mapbox.com/api/search/search/#retrieve-a-suggestion).\n *\n * Session tokens are used for [billing](https://docs.mapbox.com/api/search/search/#search-api-pricing) and\n * customer-accessible analytics.\n *\n * A [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value is recommended,\n * and is generated if an `id` is not provided.\n *\n * Note that any method that accepts a `SessionToken` object as an argument or option\n * can also accept a unique `string` and will perform an implicit conversion.\n * This flexible type is documented as {@link SessionTokenLike}.\n *\n * @name SessionToken\n * @example\n * ```typescript\n * const token = new SessionToken();\n * console.log(token.id); // = I am a UUIDv4 value!\n * ```\n */\nexport class SessionToken {\n  /**\n   * The session token in string format.\n   */\n  readonly id: string;\n\n  constructor(id?: string) {\n    this.id = id ?? generateUUID();\n  }\n\n  /**\n   * Returns the session token in string format.\n   *\n   * This is the same as calling `token.id`, and is okay to be used for serialization.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Converts a string to a `SessionToken` object.\n   *\n   * If a `SessionToken` object is passed in, the function returns a copy.\n   */\n  static convert(token: SessionToken | string): SessionToken {\n    return new SessionToken(\n      token instanceof SessionToken ? token.id : token.toString()\n    );\n  }\n}\n\n/**\n * A {@link SessionToken} object or string representing a Mapbox Search API session token.\n *\n * It's recommended this value is a [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value.\n *\n * @typedef SessionTokenLike\n * @type {SessionToken | string}\n * @example\n * const v1 = new SessionToken();\n * const v2 = new SessionToken('f06e7531-6373-4d5a-8614-b6f313488050');\n * const v3 = 'f06e7531-6373-4d5a-8614-b6f313488050';\n */\nexport type SessionTokenLike = string | SessionToken;\n", "export const UNKNOWN_ERROR = 'Unknown error';\n\n/**\n * Thrown from Search JS Core functions when a network request fails.\n *\n * See common errors here:\n * - [MapboxSearch](https://docs.mapbox.com/api/search/search/#search-api-errors)\n * - [MapboxAutofill](https://docs.mapbox.com/api/search/geocoding/#geocoding-api-errors)\n */\nexport class MapboxError extends Error {\n  readonly statusCode: number;\n\n  constructor(json: Record<string, unknown>, statusCode: number) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = 'MapboxError';\n    this.statusCode = statusCode;\n  }\n\n  /**\n   * Modified Error toString() method to include the status code.\n   */\n  toString(): string {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n}\n\n/**\n * Utility function to see if the result is \"ok\" (in 200 range).\n *\n * If not, throw a {@link MapboxError} filled out by the\n * [JSON error format](https://docs.mapbox.com/api/search/search/#search-api-errors).\n */\nexport async function handleNonOkRes(res: Response): Promise<void> {\n  if (!res.ok) {\n    const json = await res.json();\n    throw new MapboxError(json, res.status);\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// GLOBALS\nlet _fetchImpl: typeof fetch = globalThis.fetch;\nlet _abortControllerImpl: typeof AbortController = globalThis.AbortController;\n\ninterface FetchImplementation {\n  fetch: typeof fetch;\n  AbortController: typeof AbortController;\n}\n\n/**\n * Polyfills {@link fetch} implementation used in Search JS Core.\n *\n * If a `fetch` implementation is already available, the polyfill will be\n * silently ignored.\n *\n * When running Search JS Core in a Node.js environment, fetch must be either\n * polyfilled globally or passed into this function before usage of\n * internal library functionality.\n *\n * @param opts Options for the polyfill.\n * @param {fetch} opts.fetch Required. A custom `fetch` implementation.\n * @param {AbortController} opts.AbortController Required. A custom `AbortController` implementation.\n * @param {boolean} force If `true`, the polyfill will be forced to load. Otherwise, it will only load if `fetch` is not available.\n */\nexport function polyfillFetch(\n  { fetch, AbortController }: FetchImplementation,\n  force = false\n): void {\n  if (!fetch) {\n    throw new Error(\n      'Fetch implementation must include implementations of `fetch`.'\n    );\n  }\n\n  if (_fetchImpl && !force) {\n    return;\n  }\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\n\n/**\n * Returns the {@link FetchImplementation} used by Search JS Core.\n */\nexport function getFetch(): FetchImplementation {\n  if (!_fetchImpl) {\n    throw new Error(\n      'Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.'\n    );\n  }\n\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n", "type Primitive = string | number | boolean | null;\n\n/**\n * tl;dr - [classnames](https://www.npmjs.com/package/classnames) for query parameters.\n *\n * Encodes query parameters into a stringified form, good for use with {@link URL#search}.\n * Objects are key-value pairs, and if a falsy object is passed, it will be omitted.\n *\n * Null and undefined values are ignored.\n * Array values are encoded as comma-separated values.\n *\n * @example\n * ```typescript\n * const limit = 0;\n * const offset = null;\n * const params = queryParams(\n *  {\n *    q: 'pizza',\n *    c: null\n *  },\n *  (limit != null) && { limit },\n *  (offset != null) && { offset }\n * );\n * console.log(params); // = 'q=pizza&limit=0'\n * ```\n */\nexport function queryParams<T extends Record<string, Primitive>>(\n  ...objects: (T | false)[]\n): string {\n  const params = [];\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    const entries = Object.entries(obj);\n    for (const [key, value] of entries) {\n      if (value == null) continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n\n  return params.join('&');\n}\n", "import {\n  ENDPOINT_RETRIEVE,\n  ENDPOINT_SUGGEST,\n  FORWARD_URL,\n  PERMANENT_FORWARD_URL,\n  PERMANENT_REVERSE_URL,\n  RETRIEVE_URL,\n  REVERSE_URL,\n  SUGGEST_URL\n} from './constants';\nimport {\n  AdministrativeUnitTypes,\n  Suggestion,\n  FeatureSuggestion\n} from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism works in the same way as the [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests\n   * together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef Options\n */\nexport interface Options {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * The navigation routing profile to use for distance/eta calculations.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  navigation_profile?: 'driving' | 'walking' | 'cycling';\n  /**\n   * The location from which to calculate distance. **This parameter may incur additional latency.**\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  origin: string | LngLatLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n  /**\n   * Used to estimate the time of arrival from {@link Options#origin}. **This parameter may incur additional latency.**\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  eta_type?: 'navigation';\n  /**\n   * Limit results to one or more types of features. If no types are specified, all possible types may be returned.\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#administrative-unit-types\n   */\n  types?: string | Set<AdministrativeUnitTypes>;\n}\n\ninterface PermanentOptions {\n  /**\n   * The permanent endpoints are used for use cases that require storing\n   * position data. If 'true', the permanent endpoints will be used, which are\n   * billed separately.\n   *\n   * If you're interested in using {@link PermanentOptions#permanent}, contact\n   * [Mapbox sales](https://www.mapbox.com/contact/sales/).\n   *\n   * It's important to speak with an Account Manager on the Sales team prior to making requests\n   * with {@link PermanentOptions#permanent} set to `true`, as unsuccessful requests\n   * made by an account that does not have access to the endpoint may be billable.\n   */\n  permanent: boolean;\n}\n\n/**\n * @typedef SuggestionResponse\n */\nexport interface SuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: Suggestion[];\n}\n\n/**\n * @typedef RetrieveResponse\n */\nexport interface RetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: FeatureSuggestion[];\n}\n\n/**\n * A `MapboxSearch` object is an application's main entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/).\n *\n * `MapboxSearch` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxSearch#suggest}: The user enters a search term, and a list of suggested results is returned with\n *      optional data such as: eta, distance calculations, etc.\n *   2. {@link MapboxSearch#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned for displaying on a map or otherwise manipulating.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxSearch`, and\n * other options may be specified either in the constructor or in the {@link MapboxSearch#suggest} call.\n *\n * @class MapboxSearch\n * @param {Options} [options]\n * @param {string} [options.accessToken]\n *\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n *\n * const sessionToken = new SessionToken();\n * const result = await search.suggest('Washington D.C.', { sessionToken });\n * if (result.suggestions.length === 0) return;\n *\n * const suggestion = result.suggestions[0];\n * if (search.canRetrieve(suggestion)) {\n *  const { features } = await search.retrieve(suggestion, { sessionToken });\n *  doSomethingWithCoordinates(features);\n * } else if (search.canSuggest(suggestion)) {\n *   // .. go through suggest flow again ..\n * }\n * ```\n */\nexport class MapboxSearch {\n  static defaults: Partial<Options> = {\n    language: 'en'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link Options}) to be merged into options in the following methods:\n   * - {@link MapboxSearch#suggest}\n   * - {@link MapboxSearch#forward}\n   * - {@link MapboxSearch#reverse}\n   */\n  defaults: Partial<Options>;\n\n  constructor(options: Partial<AccessTokenOptions & Options> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxSearch.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Interactive search} */\n\n  /**\n   * {@link MapboxSearch#suggest} is \"part one\" of the two-step interactive search experience, and includes\n   * useful information such as: {@link Suggestion#feature_name}, {@link Suggestion#description}, and {@link Suggestion#maki}.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * It may be useful to call {@link MapboxSearch#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link MapboxSearch#canSuggest}, and further calls to {@link MapboxSearch#suggest}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {string} searchText\n   * @param {Options} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & Options>\n  ): Promise<SuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n      throw new Error(\n        'to provide eta estimate: eta, navigation_profile, and origin are required'\n      );\n    }\n    if (options.origin && !options.navigation_profile) {\n      throw new Error(\n        'to provide distance estimate: both navigation_profile and origin are required'\n      );\n    }\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as SuggestionResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link MapboxSearch#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * feature suggestions should come from the {@link MapboxSearch#forward} method\n   * with {@link PermanentOptions#permanent} enabled.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {any} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<RetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(RETRIEVE_URL);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      ...this.#getFetchInfo(suggestion),\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_RETRIEVE;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_SUGGEST;\n  }\n\n  /** @section {Programmatic search} */\n\n  /**\n   * {@link MapboxSearch#forward} is our programmatic one-step search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async forward(\n    searchText: string,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#reverse} allows you to look up a geographic coordinate pair\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param lngLat - Either a {@link LngLatLike} object or string in 'lng,lat' comma-separated format.\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async reverse(\n    lngLat: string | LngLatLike,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!lngLat) {\n      throw new Error('lngLat is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const searchText =\n      typeof lngLat === 'string'\n        ? lngLat\n        : LngLat.convert(lngLat).toArray().join(',');\n\n    const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxSearch#suggest} and\n   * {@link MapboxSearch#forward}.\n   */\n  #getQueryParams(options: Partial<Options & SessionTokenOptions>): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit,\n        navigation_profile: options.navigation_profile,\n        eta_type: options.eta_type\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.origin && {\n        origin:\n          typeof options.origin === 'string'\n            ? options.origin\n            : LngLat.convert(options.origin).toArray().join(',')\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n  }\n\n  /**\n   * Gets a partial fetch request from this suggestion's action.\n   */\n  #getFetchInfo(suggestion: Suggestion): Partial<RequestInit> {\n    if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n      throw new Error('Suggestion cannot be retrieved or suggested');\n    }\n\n    const action = suggestion.action;\n    const body = JSON.stringify(action.body);\n\n    return {\n      method: action.method,\n      body,\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': body.length.toString()\n      }\n    };\n  }\n}\n", "export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n", "import { RETRIEVE_URL, SUGGEST_URL } from './constants';\nimport { AutofillSuggestion, AutofillFeatureSuggestion } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef AutofillOptions\n */\nexport interface AutofillOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link AutofillOptions#proximity} and {@link AutofillOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef AutofillSuggestionResponse\n */\nexport interface AutofillSuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: AutofillSuggestion[];\n}\n\n/**\n * @typedef AutofillRetrieveResponse\n */\nexport interface AutofillRetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: AutofillFeatureSuggestion[];\n}\n\n/**\n * A `MapboxAutofill` object is an application's main entrypoint to the\n * Mapbox Autofill API. The Mapbox Autofill API is an API similar to {@link MapboxSearch},\n * but targeted towards **address** autocomplete.\n *\n * Only address types are returned by the API.\n *\n * `MapboxAutofill` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxAutofill#suggest}: The user enters a search term, and a list of suggested results is returned with\n *     address data.\n *   2. {@link MapboxAutofill#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxAutofill`, and\n * other options may be specified either in the constructor or in the {@link MapboxAutofill#suggest} call.\n *\n * @class MapboxAutofill\n * @param {AutofillOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxAutofill {\n  static defaults: Partial<AutofillOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link AutofillOptions}) to be merged into options in the following methods:\n   * - {@link MapboxAutofill#suggest}\n   *\n   * @type {AutofillOptions}\n   */\n  defaults: Partial<AutofillOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & AutofillOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxAutofill.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxAutofill#suggest} is \"part one\" of the two-step autofill experience, and includes\n   * autofill information.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & AutofillOptions>\n  ): Promise<AutofillSuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillSuggestionResponse;\n\n    // Add 'original_search_text' so we can retrieve.\n    return {\n      ...json,\n      suggestions: json.suggestions.map((suggestion) => {\n        return {\n          ...suggestion,\n          original_search_text: searchText\n        };\n      })\n    };\n  }\n\n  /**\n   * {@link MapboxAutofill#retrieve} is \"part two\" of the two-step autofill experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link AutofillSuggestion} returned from \"part one,\"\n   * {@link MapboxAutofill#suggest}.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: AutofillSuggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<AutofillRetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(`${RETRIEVE_URL}/${suggestion.action.id}`);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), { signal });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillRetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxAutofill#suggest}\n   */\n  #getQueryParams(\n    options: Partial<AutofillOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n\n  /**\n   * Returns true if {@link MapboxAutofill#retrieve} can be called on this suggestion,\n   * false otherwise.\n   */\n  canRetrieve(suggestion: AutofillSuggestion): boolean {\n    const action = suggestion.action;\n\n    return typeof action?.id === 'string';\n  }\n}\n", "/**\n * @typedef MatchCodeConfidence\n */\nexport const enum MatchCodeConfidence {\n  /**\n   * An exact match.\n   */\n  exact = 'exact',\n  /**\n   * High confidence of a match.\n   */\n  high = 'high',\n  /**\n   * Medium confidence of a match.\n   */\n  medium = 'medium',\n  /**\n   * Low confidence of a match.\n   */\n  low = 'low'\n}\n\n/**\n * An object describing the level of confidence that the given response feature matches the address intended by the request query.\n * Includes boolean flags denoting matches for each address sub-component.\n *\n * @typedef MatchCode\n */\nexport interface MatchCode {\n  /**\n   * A measure of confidence that the returned feature suggestion matches the intended address, based on the search text provided.\n   */\n  confidence: MatchCodeConfidence;\n  /**\n   * True if the confidence value is \"exact\".\n   */\n  exact_match: boolean;\n  /**\n   * True if the house number component was matched.\n   */\n  house_number: boolean;\n  /**\n   * True if the street component was matched.\n   */\n  street: boolean;\n  /**\n   * True if the postcode was matched.\n   */\n  postcode: boolean;\n  /**\n   * True if the place component was matched.\n   */\n  place: boolean;\n  /**\n   * True if the region component was matched.\n   */\n  region?: boolean;\n  /**\n   * True if the locality component was matched.\n   */\n  locality?: boolean;\n}\n", "/**\n * `Evented` mixes methods into other classes for event capabilities.\n *\n * If you are an end-user, you will most likely use these methods through\n * classes like {@link SearchSession}.\n *\n * For lists of events you can listen for, see API documentation for\n * specific classes.\n *\n * @class Evented\n */\nexport class Evented<T> {\n  #listeners: Partial<{\n    [key in keyof T]: ((arg0: T[key]) => void)[];\n  }> = {};\n\n  /**\n   * Adds a listener to a specified event type.\n   *\n   * @param type - The event type to add a listen for.\n   * @param listener - The function to be called when the event is fired.\n   */\n  addEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // Create listener if doesn't already exist.\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n\n    listenersArr[type].push(listener);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   *\n   * @param type - The event type to remove listeners for.\n   * @param listener - The listener function to remove.\n   */\n  removeEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fire<K extends keyof T>(type: K, arg0: T[K]): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n}\n", "/**\n * Version of the classic `debounce` function that accepts a `signalFn`\n * argument, which can return an {@link AbortSignal}.\n */\nexport function debounce<F extends (...args: unknown[]) => unknown>(\n  func: F,\n  wait: number,\n  signalFn?: () => AbortSignal\n): F {\n  let timeout = null;\n\n  return ((...args: Parameters<F>) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (signal?.aborted) {\n        return;\n      }\n      func(...args);\n    }, wait);\n  }) as F;\n}\n", "/* eslint-disable prefer-const */\nimport { SessionToken, SessionTokenLike } from './SessionToken';\n\nimport { getFetch } from './fetch';\n\nimport { Evented } from './utils/Evented';\nimport { debounce } from './utils/debounce';\n\n/**\n * Shortcut function to create a new AbortController from the polyfill.\n */\nfunction createAbortController(): AbortController {\n  const { AbortController } = getFetch();\n  return new AbortController();\n}\n\ninterface EventTypes<SuggestionResponse, RetrieveResponse> {\n  suggest: SuggestionResponse;\n  suggesterror: Error;\n  retrieve: RetrieveResponse;\n}\n\n/**\n * TypeScript magic section: what is this?\n *\n * Despite the name {@link SearchSession}, in Search JS Web we use it to control\n * both {@link MapboxSearch} **and** {@link MapboxAutofill} instances. Both\n * of these have similar workflows, but are separate APIs with different options\n * and responses.\n *\n * In order to make TypeScript happy, this type is an \"approximation\" of what\n * {@link SearchSession} uses. When you construct a new {@link SearchSession},\n * because of this type [Options, Suggestion, SuggestionResponse, RetrieveResponse]\n * are automatically inferred.\n *\n * @internal\n * @example\n * ```typescript\n * const autofill = new MapboxAutofill({\n *  accessToken: 'pk.my-fancy-token',\n * });\n *\n * const session = new SearchSession(autofill);\n *\n * `session` has inferred type = SearchSession<\n *   AutofillOptions,\n *   AutofillSuggestion,\n *   AutofillSuggestionResponse,\n *   AutofillRetrieveResponse\n * >\n * ```\n */\ntype SuggestSearch<Options, Suggestion, SuggestionResponse, RetrieveResponse> =\n  {\n    suggest: (\n      text: string,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n        signal: AbortSignal;\n      }\n    ) => Promise<SuggestionResponse>;\n    retrieve: (\n      suggestion: Suggestion,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n      }\n    ) => Promise<RetrieveResponse>;\n    canRetrieve?: (suggestion: Suggestion) => boolean;\n    canSuggest?: (suggestion: Suggestion) => boolean;\n  };\n\n/**\n * A `SearchSession` object is a managed entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/)\n * or Mapbox Autocomplete API.\n *\n * `SearchSession` abstracts the suggest/retrieve flow of the two-step interactive search experience.\n *\n * Compared to using these APIs directly, you can use a `SearchSession` to:\n * 1. Automatically manage the session token lifecycle.\n * 2. Debounce calls to {@link SearchSession#suggest}.\n * 2. Abort in-flight requests with an imperative API.\n *\n * @class SearchSession\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n * const session = new SearchSession(search);\n *\n * session.addEventListener('suggest', (res) => {\n *   presentResultsToUser(res.suggestions);\n * });\n *\n * session.addEventListener('retrieve', (res) => {\n *   doSomethingWithFeatureCollection(res);\n * });\n *\n * document.querySelector('button').addEventListener('click', (event) => {\n *   const suggestions = session.suggestions?.suggestions;\n *   if (!suggestions || !suggestions.length) {\n *     return;\n *   }\n *\n *   const suggestion = suggestions[0];\n *   if (session.canRetrieve(suggestion)) {\n *     session.retrieve(suggestion);\n *   } else if (session.canSuggest(suggestion)) {\n *     // .. go through suggest flow again ..\n *     session.suggest(suggestion.text);\n *   }\n * });\n *\n * session.suggest('Washington D.C.');\n * ```\n * @param {MapboxSearch | MapboxAutofill} search - The search interface to wrap.\n * @param {number} wait - The time in milliseconds to wait before sending a new request to the {@link SearchSession#suggest} call.\n */\nexport class SearchSession<\n  Options,\n  Suggestion,\n  SuggestionResponse,\n  RetrieveResponse\n> extends Evented<EventTypes<SuggestionResponse, RetrieveResponse>> {\n  readonly search: SuggestSearch<\n    Options,\n    Suggestion,\n    SuggestionResponse,\n    RetrieveResponse\n  >;\n\n  /**\n   * The time in milliseconds to wait before sending a new request to the\n   * {@link SearchSession#suggest} call.\n   */\n  readonly debounce: number;\n\n  /**\n   * The session token is an SKU (billing token) used to identify the current\n   * search session and provide analytics to the customer.\n   *\n   * As per {@link SessionToken}, this is a UUIDv4 value.\n   *\n   */\n  sessionToken = new SessionToken();\n\n  #suggestions: SuggestionResponse | null;\n\n  /**\n   * The suggestions from the last successful suggest call, if any.\n   */\n  get suggestions(): SuggestionResponse | null {\n    return this.#suggestions;\n  }\n\n  constructor(\n    search: SuggestSearch<\n      Options,\n      Suggestion,\n      SuggestionResponse,\n      RetrieveResponse\n    >,\n    wait = 0\n  ) {\n    super();\n\n    // Set 'suggest' method using debounce.\n    this.#suggestDebounce = debounce(\n      async (\n        searchText: string,\n        options: Partial<Options> = {}\n      ): Promise<void> => {\n        // Refresh abort controller.\n        this.#abort.abort();\n        this.#abort = createAbortController();\n\n        if (!searchText) {\n          this.#suggestions = null;\n          this.fire('suggest', this.#suggestions);\n          return;\n        }\n\n        try {\n          const res = await this.search.suggest(searchText, {\n            sessionToken: this.sessionToken,\n            ...options,\n            signal: this.#abort.signal\n          });\n\n          this.#suggestions = res;\n          this.fire('suggest', res);\n        } catch (err) {\n          if (err.name === 'AbortError') {\n            return;\n          }\n\n          this.fire('suggesterror', err);\n        }\n      },\n      wait,\n      () => this.#abort.signal\n    );\n\n    /**\n     * Define properties using {@link Object#defineProperties} so they are readonly during runtime,\n     * not just in TypeScript.\n     */\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n\n  /**\n   * The {@link AbortController} is used to abort the current suggest, either\n   * because of a new {@link SearchSession#suggest} call, or because\n   * of {@link SearchSession#abort}.\n   *\n   * In both of these cases, a new {@link AbortController} is created,\n   * and the old one is aborted.\n   */\n  #abort = createAbortController();\n\n  #suggestDebounce: (searchText: string, options?: Partial<Options>) => void;\n\n  /** @section {Methods} */\n\n  /**\n   * {@link SearchSession#suggest} is \"part one\" of the two-step interactive search experience,\n   * and each suggestion includes metadata to present to the user.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link SearchSession#retrieve}.\n   *\n   * It may be useful to call {@link SearchSession#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link SearchSession#canSuggest}, and further calls to {@link SearchSession#suggest}.\n   *\n   * Results can be retrieved with the \"suggest\" event.\n   *\n   * @example\n   * ```typescript\n   * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n   * const session = new SearchSession(search);\n   *\n   * session.addEventListener('suggest', (res) => {\n   *   presentResultsToUser(res.suggestions);\n   * });\n   *\n   * session.suggest('Washington D.C.');\n   * ```\n   */\n  suggest(\n    searchText: string,\n    options?: Partial<Options>\n  ): Promise<SuggestionResponse> {\n    this.#suggestDebounce(searchText, options);\n\n    return new Promise((resolve, reject) => {\n      let suggestFn: (val: SuggestionResponse) => void;\n      let suggestErrorFn: (val: Error) => void;\n\n      suggestFn = (res) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        resolve(res);\n      };\n      suggestErrorFn = (err) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        reject(err);\n      };\n\n      this.addEventListener('suggest', suggestFn);\n      this.addEventListener('suggesterror', suggestErrorFn);\n    });\n  }\n\n  /**\n   * Clears the current suggestions.\n   */\n  clear(): void {\n    this.suggest('');\n  }\n\n  /**\n   * {@link SearchSession#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link SearchSession#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, results should not be stored in a customer database.\n   * Results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    options?: Partial<Options>\n  ): Promise<RetrieveResponse> {\n    const res = await this.search.retrieve(suggestion, {\n      sessionToken: this.sessionToken,\n      ...options\n    });\n\n    this.fire('retrieve', res);\n    return res;\n  }\n\n  /**\n   * Returns true if {@link SearchSession#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n\n    return this.search.canRetrieve(suggestion);\n  }\n\n  /**\n   * Returns true if {@link SearchSession#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n\n    return this.search.canSuggest(suggestion);\n  }\n\n  /**\n   * Aborts the current {@link SearchSession#suggest} request.\n   */\n  abort(): void {\n    this.#abort.abort();\n    this.#abort = createAbortController();\n  }\n}\n", "import { FeatureSuggestion, Suggestion } from './search/types';\nimport {\n  AutofillFeatureSuggestion,\n  AutofillSuggestion\n} from './autofill/types';\n\nfunction featureToSuggestion(feature: FeatureSuggestion): Suggestion;\n\nfunction featureToSuggestion(\n  feature: AutofillFeatureSuggestion\n): AutofillSuggestion;\n\n/**\n * Utility function to convert the {@link FeatureSuggestion} properties to a\n * {@link Suggestion} object.\n */\nfunction featureToSuggestion(\n  feature: FeatureSuggestion | AutofillFeatureSuggestion\n): Suggestion | Omit<AutofillSuggestion, 'original_search_text' | 'action'> {\n  const { properties } = feature;\n  return {\n    ...properties\n  };\n}\n\nexport { featureToSuggestion };\n", "export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_VALIDATE = 'retrieve';\n\nexport const VALIDATE_URL = `${SEARCH_URL}/${ENDPOINT_VALIDATE}`;\n", "import { VALIDATE_URL } from './constants';\nimport { ValidateFeature } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef ValidateOptions\n */\nexport interface ValidateOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link ValidateOptions#proximity} and {@link ValidateOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef ValidateResponse\n */\nexport interface ValidateResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: ValidateFeature[];\n}\n\n/**\n * A `MapboxValidate` object is an application's main entrypoint to the\n * Mapbox Validate API. The Mapbox Validate API is an API similar to {@link MapboxAutofill},\n * but targeted at checking **address**.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxValidate`, and\n * other options may be specified either in the constructor or in the {@link MapboxValidate#validate} call.\n *\n * @class MapboxValidate\n * @param {ValidateOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxValidate {\n  static defaults: Partial<ValidateOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link ValidateOptions}) to be merged into options in the following methods:\n   * - {@link ValidateOptions#validate}\n   *\n   * @type {ValidateOptions}\n   */\n  defaults: Partial<ValidateOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & ValidateOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxValidate.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxValidate#validate} allows you to validate an address\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {String} searchText\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async validate(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<ValidateResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as ValidateResponse;\n\n    if (json.features.length > 0) {\n      json.features = [json.features[0]];\n    }\n\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxValidate#validate}\n   */\n  #getQueryParams(\n    options: Partial<ValidateOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
